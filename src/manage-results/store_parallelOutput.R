#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
# This script contains functions to process the combined output from a simulation study
# (as generated by `load_seedOutput`) and store it in a cell-specific .RData file
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!

store_simStudyResults <- function(output, saveTo = "./", simStudyName = "sim_results"){
  # Create the output directory if it doesn't exist
  dir.create(saveTo, recursive = TRUE, showWarnings = FALSE)

  # Identify available top-level result dataframes (e.g., "noEffect", "fixedEffect")
  available_results <- setdiff(names(output), c("reps", "settings"))

  if (length(available_results) == 0) {
    warning("No result dataframes found in output (e.g., 'noEffect', 'fixedEffect'). No files will be created.")
    return(invisible(NULL))
  }

  # Loop over each result type (e.g., "noEffect", "fixedEffect")
  for (result_type in available_results) {
    result_df <- output[[result_type]]
    if (is.null(result_df) || nrow(result_df) == 0) next
    
    # Identify the model conditions, which are the columns other than metadata
    metadata_cols <- c("p", "t", "seed", "beta", "true_values") 
    model_conditions <- setdiff(colnames(result_df), metadata_cols)

    # Loop over each model condition column and process it
    for (condition_name in model_conditions) {
      cat(paste0("\nProcessing: ", result_type, " - ", condition_name, "\n"))
      
      # Call the helper function to extract and structure the data
      processed_data <- process_condition(
        source_df = result_df, 
        condition_col_name = condition_name, 
        settings = output$settings, 
        reps = output$reps
      )
      
      # Save the structured data to a file
      if (!is.null(processed_data)) {
        fileName <- file.path(saveTo, paste0(simStudyName, "_", result_type, "_", condition_name, ".RData"))
        save(processed_data, file = fileName)
        cat(paste0("Saved results to ", fileName, "\n"))
      }
    }
  }
  
  cat("\nProcessing complete.\n")
}

#' @title Helper function to process results for a single model condition
#' @description This function restructures a flat dataframe of simulation results
#' into a list of 3D arrays, organized by participant level.
#' @param source_df The dataframe to process (e.g., output$fixedEffect).
#' @param condition_col_name The specific column containing JAGS results (e.g., "EZ_clean").
#' @param settings The simulation settings list.
#' @param reps The dataframe of JAGS/Rhat reruns.
#' @return A list containing the restructured data, or NULL on failure.
process_condition <- function(source_df, condition_col_name, settings, reps) {
  participant_levels <- settings$participant_levels
  trial_levels <- settings$trial_levels
  n_seeds <- if (!is.null(reps)) nrow(reps) else 0

  # --- 1. Initialization and Validation ---
  storage <- list(
    true_params = list(),
    estimates = list(),
    sds = list(),
    rhats = list()
  )

  # Find first valid entries to get parameter names
  first_true_vals <- source_df$true_values[[1]]
  first_jags_result <- NULL
  for (item in source_df[[condition_col_name]]) {
    if (!is.null(item)) {
      first_jags_result <- item
      break
    }
  }

  if (is.null(first_jags_result) || is.null(first_true_vals)) {
    warning(paste("Cannot process condition '", condition_col_name, "' due to missing data.", sep = ""))
    return(NULL)
  }

  param_names_true <- names(first_true_vals)
  param_names_est <- names(first_jags_result$estimates)
  param_names_rhats <- names(first_jags_result$rhats)

  # --- 2. Create and Fill 3D Arrays ---
  for (p in participant_levels) {
    # Initialize arrays for this P-level
    p_name <- paste0("p_", p)
    storage$true_params[[p_name]] <- array(NA, dim = c(n_seeds, length(param_names_true), length(trial_levels)), dimnames = list(paste0("seed_", 1:n_seeds), param_names_true, paste0("trials_", trial_levels)))
    storage$estimates[[p_name]] <- array(NA, dim = c(n_seeds, length(param_names_est), length(trial_levels)), dimnames = list(paste0("seed_", 1:n_seeds), param_names_est, paste0("trials_", trial_levels)))
    storage$sds[[p_name]] <- array(NA, dim = c(n_seeds, length(param_names_est), length(trial_levels)), dimnames = list(paste0("seed_", 1:n_seeds), param_names_est, paste0("trials_", trial_levels)))
    storage$rhats[[p_name]] <- array(NA, dim = c(n_seeds, length(param_names_rhats), length(trial_levels)), dimnames = list(paste0("seed_", 1:n_seeds), param_names_rhats, paste0("trials_", trial_levels)))

    for (j in seq_along(trial_levels)) {
      t <- trial_levels[j]
      # Filter the dataframe once per T-level for efficiency
      t_filtered_df <- source_df[source_df$p == p & source_df$t == t, ]
      
      for (k in 1:n_seeds) {
        # Find the specific row for this seed
        row_data <- t_filtered_df[t_filtered_df$seed == k, ]
        
        if (nrow(row_data) == 1) {
          jags_results <- row_data[[condition_col_name]][[1]]
          
          if (!is.null(jags_results)) {
            storage$true_params[[p_name]][k, , j] <- unlist(row_data$true_values[[1]])
            storage$estimates[[p_name]][k, , j]   <- unlist(jags_results$estimates)
            storage$sds[[p_name]][k, , j]         <- unlist(jags_results$sd)
            storage$rhats[[p_name]][k, , j]       <- unlist(jags_results$rhats)
          }
        }
      }
    }
  }

  # --- 3. Assemble Final Output ---
  final_results <- list(
    reps = reps,
    settings = settings,
    true_parameters = storage$true_params,
    estimates = storage$estimates,
    sds = storage$sds,
    rhats = storage$rhats
  )
  
  return(final_results)
}





